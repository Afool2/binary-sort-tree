<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>binary sort tree</title>
</head>
<body>
    <script type="text/javascript">
        var cl = console.log;
        function binaryTree() {
            var node = function(key) {
                this.key = key;
                this.left = null;
                this.right = null;
            };
            //根节点
            var root = null;
           
            //插入结点的方法
            var insertNode = function(node, newNode) {
                if(newNode.key < node.key) {
                    if(node.left === null) {
                        node.left = newNode;
                    }else{
                        insertNode(node.left, newNode);
                    }
                }else{
                    if(node.right === null) {
                        node.right = newNode;
                    }else{
                        insertNode(node.right, newNode);
                    }
                }
            };
            
            // 插入结点
            this.insert = function(key) {
                var newNode = new node(key);
                if(root === null) {
                    root = newNode;
                }else{
                    insertNode(root, newNode);
                }
                return root;
            };

            // 中序遍历<左根右>,用于升序排序
            function inOrderTraverseNode(node, callback) {
                if(node !== null) {
                    inOrderTraverseNode(node.left, callback);
                    callback(node.key);
                    inOrderTraverseNode(node.right, callback);
                }
            }
            this.inOrderTraverse = function(callback) {
                inOrderTraverseNode(root, callback);
                
            };

            // 前序遍历<根左右>：用于复制二叉树，比重新构建二叉树快约10倍
            function preorderTraverseNode(node, callback) {
                if(node !== null) {
                    callback(node.key);
                    preorderTraverseNode(node.left, callback);
                    preorderTraverseNode(node.right, callback);
                }
            }
            this.preorderTraverse = function(callback) {
                preorderTraverseNode(root, callback);
            };
            
            // 后序遍历<左右根>,可用于文件系统的遍历
            function postorderTraverseNode(node, callback) {
                if(node !== null) {
                    postorderTraverseNode(node.left, callback);
                    postorderTraverseNode(node.right, callback);
                    callback(node.key);
                }
            }
            this.postorderTraverse = function(callback) {
                postorderTraverseNode(root, callback);

            };
            
            // 查找二叉树的最小结点
            function minNode(node) {
                if(node) {
                    while(node && node.left !== null) {
                        node = node.left;
                    }
                    return node.key;
                }
                return null;
            }
            this.min = function() {
                return minNode(root);
            };

            // 查找二叉树的最大结点
            function maxNode(node) {
                if(node) {
                    while(node && node.right !== null) {
                        node = node.right;
                    }
                    return node.key;
                }
                return null;
            }
            this.max = function() {
                return maxNode(root);
            }

            // 查找某个值在二叉树中是否存在
            function searchNode(node, value) {
                if(node === null) return false;
                if(node.key === value) return true;
                if(value < node.key) {
                    return searchNode(node.left, value);
                }else{
                    return searchNode(node.right, value);
                }
            }
            this.search = function(value) {
                
                return searchNode(root, value);
            };

            //删除二叉树的结点
            function removeNode(node, value) {
                if(node === null) return null;
                if(value < node.key) {
                    node.left = removeNode(node.left, value);
                }else if(value > node.key) {
                    node.right = removeNode(node.right, value);
                }else{
                    if(node.left === null && node.right === null) {// 删除叶子结点
                        node = null;
                    }else if(node.left === null){// 删除有且仅有右子树的中间结点
                        node = node.right;
                    }else if(node.right === null){// 删除有且仅有左子树的中间结点
                        node = node.left;
                    }else{// 删除含有左右子树的结点，即删除该结点的右子树的最小结点aux，并把aux的值赋给该结点
                        var aux = findMinNode(node.right);
                        node.key = aux.key;
                        node.right = removeNode(node.right, aux.key);
                    }

                }
                return node;
            }
            this.remove = function(value) {
                root = removeNode(root, value);
            }

            function findMinNode(node) {// 返回最小结点
                if(node) {
                    while(node && node.left !== null) {
                        node = node.left;
                    }
                    return node;
                }
                return null;
            }
        }
        
        var arr = [7,8,2,1,0,4,9,5,3,6];
        var aBinaryTree = new binaryTree();
        // 创建二叉树
        var tree;
        arr.forEach(function(item){
            tree = aBinaryTree.insert(item);
        });
        

        // // 中序遍历
        // cl('inOrderTraverse');
        // aBinaryTree.inOrderTraverse(function(arg) {cl(arg)});
        // // 前序遍历
        // cl('preorderTraverse');
        // aBinaryTree.preorderTraverse(function(arg) {cl(arg)});
      
        // // 后序遍历
        // cl('postorderTraverse');
        // aBinaryTree.postorderTraverse(function(e) {cl(e)});
        
        // // 找最小值
        // var a = aBinaryTree.min();

    </script>
</body>
</html>